#!/usr/bin/env python
__author__ = 'nafisa'
import rospy
import sys
import copy
import moveit_commander
import geometry_msgs.msg
from std_msgs.msg import Bool, Float32MultiArray
import tf
from moveit_msgs.msg import OrientationConstraint, Constraints
import math
from darm_interface import *

####################################################################
################# JOHNS HOPKINS UNIVERSITY #########################
################# INTERBOTIX WX200 WITH MOVEIT #####################
################# ARM node for DECON ###############################
####################################################################

class DeconARM():
	def __init__(self):

		#Topics that this node will interact with decon controller 
		self.arm_topic = rospy.Subscriber('arm_msg', Float32MultiArray, self.arm_cb)	
		self.arm_status_topic = rospy.Publisher('arm_status_msg', Bool, queue_size=1)
	
		#Basic initialisation for moveit
		moveit_commander.roscpp_initialize(sys.argv)
		self.scene = moveit_commander.PlanningSceneInterface() #ns="wx200"
        	self.robot = moveit_commander.RobotCommander(robot_description="wx200/robot_description")
        	group_name = "interbotix_arm"
        	self.group = moveit_commander.MoveGroupCommander(robot_description="wx200/robot_description",ns =    "wx200",name = group_name)

		rospy.init_node('decon_arm', anonymous=True, disable_signals=True)
		self.rate = rospy.Rate(0.1)
		
		#Attach cone as colliding object to avoid the need to restart the ARM
		self.attach_object()
		
		#Constraint to keep orientaion aligned with turtlebot
		self.constraints = Constraints()	
		self.set_orientation_constraints()
		self.group.set_path_constraints(self.constraints)

		#Save the starting pose to return to  
		self.start_pose = self.group.get_current_pose()

		rospy.loginfo("[Decon] Initiating ARM WX200...")
		rospy.spin()

	def attach_object(self):
		box_pose = geometry_msgs.msg.PoseStamped()
		eef_link = self.group.get_end_effector_link()
		box_pose.header.frame_id = eef_link
		box_pose.pose.orientation.w = 1.0
		box_name = 'cone'
		self.scene.add_box(box_name, box_pose, size=(0.25,0.25,0.25))
		grasping_group = 'interbotix_arm'
		touch_links = [eef_link] 
		self.scene.attach_box(eef_link, name=box_name, touch_links=touch_links) 

	def set_orientation_constraints(self):
		oc = OrientationConstraint()
		oc.header.frame_id = 'base_link'
		oc.link_name = 'ee_arm_link'
		oc.orientation.w = 0.5
		#quat = tf.transformations.quaternion_from_euler(math.radians(0), math.radians(0), math.radians(90))
		#oc.orientation.x = quat[0]
		#oc.orientation.y = quat[1]
		#oc.orientation.z = quat[2]
		#oc.orientation.w = quat[3]
		self.constraints.orientation_constraints.append(oc)

	def arm_cb(self, request):
		rospy.loginfo("[Decon] Request to move arm recieved...")
		if len(request.data) != 2:
			self.arm_status_topic.publish(False)
			return

		if request.data == (0.0,0.0):
			move_to_pose(self.group, self.rate, [self.start_pose.pose])
			self.arm_status_topic.publish(True)
			return
			
		
		[arm_y_offset, arm_z_offset] = request.data	
		move(self.group, self.rate, 0.36, arm_y_offset, arm_z_offset)	
		self.arm_status_topic.publish(True)
		return
		
if __name__ == '__main__':
	try:
		dcontroller = DeconARM()
	except rospy.ROSInterruptException:
		log_string = "[Decon] Decon Arm exiting at %s!" % rospy.get_time()	
		rospy.loginfo(log_string)

